import { ethers } from "ethers";
import * as dotenv from "dotenv";
import {
    FlashbotsBundleProvider,
    FlashbotsBundleResolution,
  } from "@flashbots/ethers-provider-bundle";
  
dotenv.config();

const GWEI = 10n ** 9n;
const CHAIN_ID = 5; // goerli testnetï¼Œmodify chain_id to 1 if using mainnet

// Infura RPC
const provider = new ethers.providers.InfuraProvider(CHAIN_ID, process.env.INFURA_API_KEY || '');

// This key is for the sake of reputation
const authKey = process.env.REPUTATION_KEY;
const authSigner = new ethers.Wallet(authKey, provider)

const main = async () => {


    const flashbotsProvider = await FlashbotsBundleProvider.create(
        provider,
        authSigner,
        // uncomment if using goerli testnet
        'https://relay-goerli.flashbots.net/', 
        'goerli'
        // uncomment if using goerli testnet
        );
    
    const exploited = new ethers.Wallet(process.env.PRIVATE_KEY_EXPLOITED, provider)
    const sponser = new ethers.Wallet(process.env.PRIVATE_KEY_SPONSOR, provider);
    const contractAddress = "0x1B0fD9020007fEcBaA9dFE141f16209Df04E2BF6";

  // EIP 1559 transaction
    const transaction0 = {
        chainId: CHAIN_ID,
        type: 2,
        to: exploited.address,
        value: ethers.utils.parseEther("0.001"),
        data: '0x',
        maxPriorityFeePerGas: GWEI * 20n,
        maxFeePerGas: GWEI * 100n
    };
    const transaction1 = {
        chainId: CHAIN_ID,
        type: 2,
        to: contractAddress,
        value: ethers.utils.parseEther('0'),
        maxPriorityFeePerGas: GWEI * 20n,
        maxFeePerGas: GWEI * 50n,
        data: '0x23b872dd000000000000000000000000e16c1623c1aa7d919cd2241d8b36d9e79c1be2a2000000000000000000000000f90275fae78889760ea96c20149de21452d2676b0000000000000000000000000000000000000000000000000000000000000002',
        gasLimit: '25000'
    };

    // create Bundle
    const transactionBundle = [
        {
            signer: sponser, // ethers signer
            transaction: transaction0 // ethers populated transaction object
        },
        {
            signer: exploited,
            transaction: transaction1
        }
        // any other transactions(will be included in the mempool)
        // ,{
        //     signedTransaction: SIGNED_ORACLE_UPDATE_FROM_PENDING_POOL // serialized signed transaction hex
        // }
    ]

    // Simulate transaction. only the successful ones will be sent to mempool
    // sign the transaction
    const signedTransactions = await flashbotsProvider.signBundle(transactionBundle)
    // Set target block
    const targetBlockNumber = (await provider.getBlockNumber()) + 1
    // // simulate
    // const simulation = await flashbotsProvider.simulate(signedTransactions, targetBlockNumber)
    // // check if success or net
    // if ("error" in simulation) {
    //     console.log(`Simulate error: ${simulation.error.message}`);
    // } else {
    //     console.log(`Simulate successful!`);
    //     console.log(JSON.stringify(simulation, null, 2))
    // }

    // Send transaction
    // Due to there are few nodes on flashbots testnet, so you might try many times to
    // make the transaction on chain. We send 100 blocks here 
    for (let i = 1; i <= 1000; i++) {
        let targetBlockNumberNew = targetBlockNumber + i - 1;
        // Send transaction
        const res = await flashbotsProvider.sendRawBundle(signedTransactions, targetBlockNumberNew);
        if ("error" in res) {
        throw new Error(res.error.message);
        }
        // Check if onchain already or not
        const bundleResolution = await res.wait();
        // Three status of transaction: included in block/not included in block/nonce too high
        if (bundleResolution === FlashbotsBundleResolution.BundleIncluded) {
        console.log(`Congrats, included in ${targetBlockNumberNew}`);
        console.log(JSON.stringify(res, null, 2));
        process.exit(0);
        } else if (
        bundleResolution === FlashbotsBundleResolution.BlockPassedWithoutInclusion
        ) {
        console.log(`Not included in  ${targetBlockNumberNew}`);
        } else if (
        bundleResolution === FlashbotsBundleResolution.AccountNonceTooHigh
        ) {
        console.log("Nonce too high, bailing, but transaction may still be included, check etherscan later");
        process.exit(1);
        }
    }
}

const runMain = async () => {
    try {
        await main();
        process.exit(0);
    }
    catch (error) {
        console.log(error);
        process.exit(1);
    }
}

runMain();